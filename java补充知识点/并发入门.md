# 并发基础

# 1 线程与进程

## 1.1 进程 

进程是程序的一次执行过程，是系统运行程序的基本单位，因此进程是动态的。系统运行一个程序即是一个进程从创建，运行到消亡的过程。

在 Java 中，当我们启动 main 函数时其实就是启动了一个 JVM 的进程，而 main 函数所在的线程就是这个进程中的一个线程，也称主线程。

## 1.2 线程

线程与进程相似，但线程是一个比进程更小的执行单位。一个进程在其执行的过程中可以产生多个线程。与进程不同的是同类的多个线程共享进程的**堆**和**方法区**资源，但每个线程有自己的**程序计数器**、**虚拟机栈**和**本地方法栈**，所以系统在产生一个线程，或是在各个线程之间作切换工作时，负担要比进程小得多，也正因为如此，线程也被称为轻量级进程。

## 1.3 线程与进程的关系,区别及优缺点

JAVA内存区域

![img](https://camo.githubusercontent.com/4d092eef7fd9608d8610278dee2d7b627b5980300a5019b07e59820907c806c4/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d332f4a564de8bf90e8a18ce697b6e695b0e68daee58cbae59f9f2e706e67)

一个进程中可以有多个线程，多个线程共享进程的**堆**和**方法区 (JDK1.8 之后的元空间)\**资源，但是每个线程有自己的\**程序计数器**、**虚拟机栈** 和 **本地方法栈**。

**总结：** **线程是进程划分成的更小的运行单位。线程和进程最大的不同在于基本上各进程是独立的，而各线程则不一定，因为同一进程中的线程极有可能会相互影响。线程执行开销小，但不利于资源的管理和保护；而进程正相反。**

### 程序计数器、虚拟机栈和本地方法栈为什么是私有的?

* **程序计数器**：私有主要是为了**线程切换后能恢复到正确的执行位置**。

- **虚拟机栈：** 每个 Java 方法在执行的同时会创建一个栈帧用于存储局部变量表、操作数栈、常量池引用等信息。从方法调用直至执行完成的过程，就对应着一个栈帧在 Java 虚拟机栈中入栈和出栈的过程。
- **本地方法栈：** 和虚拟机栈所发挥的作用非常相似，区别是： **虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。** 在 HotSpot 虚拟机中和 Java 虚拟机栈合二为一。

为了**保证线程中的局部变量不被别的线程访问到**，虚拟机栈和本地方法栈是线程私有的

### 堆和方法区的不同

堆和方法区是所有线程共享的资源，其中堆是进程中最大的一块内存，主要用于**存放新创建的对象** (几乎所有对象都在这里分配内存)，**方法区**主要用于存放**已被加载的类信息、常量、静态变量、即时编译器编译后的代码**等数据。

## 1.4 线程的生命周期

![系统进程/线程转换图](http://concurrent.redspider.group/article/01/imgs/%E7%B3%BB%E7%BB%9F%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2%E5%9B%BE.png)



**Java 线程**在运行的生命周期中的指定时刻只可能处于下面 6 种不同状态的其中一个状态

![Java 线程的状态 ](https://camo.githubusercontent.com/d87b3b516a8138ca3a8a1078d46d63cb25caba590ab0142721014c1949fffc0b/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f31392d312d32392f4a6176612545372542412542462545372541382538422545372539412538342545372538412542362545362538302538312e706e67)

操作系统线程主要有以下三个状态：

- 就绪状态(ready)：线程正在等待使用CPU，经调度程序调用之后可进入running状态。
- 执行状态(running)：线程正在使用CPU。
- 等待状态(waiting): 线程经过等待事件的调用或者正在等待其他资源（如I/O）。



### 1 NEW 状态

处于NEW状态的线程此时尚未启动。这里的尚未启动指的是还没调用Thread实例的start()方法。

调用**Start方法**后 线程 进入启动状态

```java
private void testStateNew() {
    Thread thread = new Thread(() -> {});
    System.out.println(thread.getState()); // 输出 NEW 
}
```

**注意: 关于start()的两个引申问题**

1. 反复调用同一个线程的start()方法是否可行？

   不可行，在调用一次start()之后，`threadStatus`的值会改变（`threadStatus` !=0），此时再次调用start()方法会抛出`IllegalThreadStateException`异常。

2. 假如一个线程执行完毕（此时处于TERMINATED状态），再次调用这个线程的start()方法是否可行？

   不可行，调用一次start()之后，`threadStatus`的值会改变，其中threadStatus为2代表当前线程状态为TERMINATED。

   

### 2 RUNNABLE状态

表示当前线程正在运行中。处于RUNNABLE状态的线程在Java虚拟机中运行，也有可能在等待CPU分配资源。他是**Ready和running两个状态的结合**。



### 3 BLOCKED状态

**阻塞状态**。处于BLOCKED状态的线程正**等待锁的释放以进入同步区。**



### 4 WAITING状态

**等待状态。**处于等待状态的线程**变成RUNNABLE状态需要其他线程唤醒**。

>调用如下3个方法会使线程进入等待状态：
>
>- `Object.wait()`：使当前线程处于等待状态直到另一个线程唤醒它；
>- `Thread.join()`：等待线程执行完毕，底层调用的是Object实例的wait方法；
>- `LockSupport.park()`：除非获得调用许可，否则禁用当前线程进行线程调度。



### 5 TIMED_WAITING状态

​	**超时等待状态**。线程等待一个具体的时间，时间到后会被自动唤醒。

>调用如下方法会使线程进入超时等待状态：
>
>- `Thread.sleep(long millis)`：使当前线程睡眠指定时间；
>- `Object.wait(long timeout)`：线程休眠指定时间，等待期间可以通过`notify()/notifyAll()`唤醒；
>- `Thread.join(long millis)`：等待当前线程最多执行`millis`毫秒，如果`millis`为0，则会一直执行；
>- `LockSupport.parkNanos(long nanos)`： 除非获得调用许可，否则禁用当前线程进行线程调度指定时间；
>- `LockSupport.parkUntil(long deadline)`：同上，也是禁止线程进行调度指定时间；

### 6 TERMINATED

终止状态。此时线程已执行完毕。

### 7 状态转移图

![线程状态转换图](http://concurrent.redspider.group/article/01/imgs/%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2%E5%9B%BE.png)

## 1.5 避免线程死锁的方法

**死锁产生原因：**

1. **互斥条件**：该资源任意一个时刻只由一个线程占用。
2. **请求与保持条件**：一个进程因请求资源而阻塞时，对已获得的资源保持不放。
3. **不剥夺条件**:线程已获得的资源在末使用完之前不能被其他线程强行剥夺，只有自己使用完毕后才释放资源。
4. **循环等待条件**:若干进程之间形成一种头尾相接的循环等待资源关系。

解决办法：

1. **破坏互斥条件** ：这个条件我们没有办法破坏，因为我们用锁本来就是想让他们互斥的（临界资源需要互斥访问）。
2. **破坏请求与保持条件** ：一次性申请所有的资源。
3. **破坏不剥夺条件** ：占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源。
4. **破坏循环等待条件** ：靠按序申请资源来预防。按某一顺序申请资源，释放资源则反序释放。破坏循环等待条件。



## 1.6 sleep方法和wait方法的不同

wait => Object 的方法
sleep => Thread  的方法

- 两者最主要的区别在于：**sleep 方法没有释放锁，而 wait 方法释放了锁** 。
- 两者都可以暂停线程的执行。
- Wait 通常被用于**线程间交互/通信**，sleep 通常被用于暂停执行。
- wait() 方法被调用后，线程**不会自动苏醒**，需要别的线程调用同一个对象上的 **notify() 或者 notifyAll() 方法**。sleep() 方法执行完成后，线程会**自动苏醒**。或者可**以使用 wait(long timeout)超时后线程会自动苏醒**。

## 1.7 为什么我们调用 start() 方法时会执行 run() 方法，为什么我们不能直接调用 run() 方法？

new 一个 Thread，线程进入了新建状态;调用 start() 方法，会启动一个线程并使线程进入了就绪状态，当分配到时间片后就可以开始运行了。 start() 会执行线程的相应准备工作，然后自动执行 run() 方法的内容，这是真正的多线程工作。 而直接执行 run() 方法，会把 run 方法当成一个 main 线程下的普通方法去执行，并不会在某个线程中执行它，所以这并不是多线程工作。

**总结： 调用 start 方法方可启动线程并使线程进入就绪状态，而 run 方法只是 thread 的一个普通方法调用，还是在主线程里执行。**





# 2 线程的基本操作

### 2.1 创建线程

~~~java
//线程的基本操作方法方法
public class MultiThread {
    public static void main(String[] args) throws InterruptedException {
        //创建线程
        //第一种方法，重写一个Thread的子类，复写其run方法,
        MyThread t = new MyThread();
        t.start();    //启动子线程
        //主线程继续同时向下执行
        for (int i = 0; i < 10000; i++) {
            System.out.print(i + " ");
        }

        //第二种方法，匿名内部类，实现Runnable接口也是一样的效果
        new Thread(new Runnable() {
            public void run() {
                for (int i = 0; i < 10; i++) {
                    System.out.print(i + " ");
                }
            }
        }).start();

        //线程的暂停,主线程暂停
        Thread.sleep(1000);
    }
}
~~~



### 2.2 中断线程

`java.lang.Thread`类有一个`interrupt`方法，该方法直接对线程调用。当被interrupt的线程正在sleep或wait时，会抛出`InterruptedException`异常。
事实上，`interrupt`方法只是改变目标线程的中断状态（interrupt status），而那些会抛出`InterruptedException`异常的方法，如wait、sleep、join等，都是在方法内部不断地检查中断状态的值。

1. **interrupted方法**

**Thread实例方法**：必须由其它线程获取被调用线程的实例后，进行调用。实际上，只是改变了被调用线程的内部中断状态；

2. **Thread.interrupted方法**

**Thread类方法**：必须在当前执行线程内调用，该方法**返回当前线程的内部中断状态**，然后清除中断状态（置为false）；

3. **isInterrupted方法**

Thread实例方法：用来检查指定线程的中断状态。当线程为中断状态时，会返回true；否则返回false。



# 3 锁Lock 和Synchronized关键字

### 3.1 Synchronized关键字简介

**`synchronized` 关键字解决的是多个线程之间访问资源的同步性，`synchronized`关键字可以保证被它修饰的方法或者代码块在任意时刻只能有一个线程执行。**

### 3.2 Synchronized关键字的使用

#### 1 修饰实例方法

​	作用于当前对象实例加锁，进入同步代码前要获得 **当前对象实例的锁**

~~~java
synchronized void method(){

}
~~~



#### 2 修饰静态方法

​	也就是给当前类加锁，会作用于类的所有对象实例 ，进入同步代码前要获得 **当前 class 的锁**。

~~~java
synchronized static void method(){

}
~~~



#### 3 修饰代码块

指定加锁对象，对给定对象/类加锁。`synchronized(this|object)` 表示进入同步代码库前要获得**给定对象的锁**。`synchronized(类.class)` 表示进入同步代码前要获得 **当前 class 的锁**

~~~
synchronized(this) {
  //业务代码
}
~~~

#### **总结：**

- `synchronized` 关键字加到 `static` 静态方法和 `synchronized(class)` 代码块上都是是给 Class 类上锁。
- `synchronized` 关键字加到**实例方法**上是给**对象实例**上锁。
- 尽量**不要使用 `synchronized(String a)`** 因为 JVM 中，字符串常量池具有缓存功能！

#### **在单例模式中的应用**

~~~java
public class Singleton {

    private volatile static Singleton uniqueInstance;

    //私有构造方法
    private Singleton() {
    }

    public  static Singleton getUniqueInstance() {
       //先判断对象是否已经实例过，没有实例化过才进入加锁代码
        if (uniqueInstance == null) {
            //类对象加锁
            synchronized (Singleton.class) {
                if (uniqueInstance == null) {
                    uniqueInstance = new Singleton();
                }
            }
        }
        return uniqueInstance;
    }
}
~~~

`uniqueInstance` 采用 `volatile` 关键字修饰也是很有必要的， `uniqueInstance = new Singleton();` 这段代码其实是分为三步执行：

1. 为 `uniqueInstance` 分配内存空间
2. 初始化 `uniqueInstance`
3. 将 `uniqueInstance` 指向分配的内存地址



### 3.3 锁ReentrantLock

#### 1 锁接口的方法：

![image-20220302202118512](C:\Users\jinhu\AppData\Roaming\Typora\typora-user-images\image-20220302202118512.png)

![image-20220302202233153](C:\Users\jinhu\AppData\Roaming\Typora\typora-user-images\image-20220302202233153.png)



~~~java
//ReentrantLock可以选择是公平锁或者非公平锁 
//公平锁就是先等待的线程先获得锁
public ReentrantLock(boolean fair) {
        sync = fair ? new FairSync() : new NonfairSync();
    }
~~~



#### 2 常见的锁的使用方法

~~~java

public class LockTest  {
    public static void main(String[] args) {
        Say say = new Say();
        new Thread(new Runnable() {
            @Override
            public void run() {
                for (int i = 0; i < 10; i++) {
                    say.say();
                }
            }
        },"A").start();

        new Thread(new Runnable() {
            @Override
            public void run() {
                for (int i = 0; i < 10; i++) {
                    say.say();
                }
            }
        },"B").start();
    }
}

//使用锁的同步
public class Say {
    private Lock lock = new ReentrantLock();
    private int i = 20;
    //该方法应用锁，同时只有一个执行
    //防止代码块受并发访问的干扰
    public void say(){
        lock.lock();
        try{
            System.out.println(Thread.currentThread().getName()+"say hello" + i);
            i--;
        }catch(Exception e){
            e.printStackTrace();
        }finally {
            lock.unlock();
        }
    }
}
//使用synchronized 关键字的同步
class Hay {
    private int i = 20;
    public synchronized  void say(){
        System.out.println(Thread.currentThread().getName()+"say hello" + i);
        i--;
    }
}
~~~



#### 3 条件对象 Condition

**在不满足条件时需要等待**

`Condition.await()`方法会放弃锁，这样其他线程就可以操作资源了。然后其他线程调用`signal()/signalAll();`通知正在等待的线程。



调用 `signalAll` 不会立即激活一个等待线程。它仅仅**解除等待线程的阻塞**， 以便这些线程可以在当前线程**退出同步方法之后， 通过竞争实现对对象的访问**。另一个方法 **signal, 则是随机解除等待集中某个线程的阻塞状态**。这比解除所有线程的阻塞更加有效，但也存在危险。 **如果随机选择的线程发现自己仍然不能运行， 那么它再次被**
**阻塞**。如果没有其他线程再次调用 signal, 那么系统就死锁了。  

Condition的使用方法：

~~~java
//按照次序打印 A B C
//需要使用while加标志位配合Condition使用
public class ConditionTest {
    public static void main(String[] args) {
        HiSay say = new HiSay();
        new Thread(new Runnable() {
            @Override
            public void run() {
                for (int i = 0; i < 10; i++) {
                    say.printA();
                }
            }
        }).start();
        new Thread(new Runnable() {
            @Override
            public void run() {
                for (int i = 0; i < 10; i++) {
                    say.printB();
                }
            }
        }).start();
        new Thread(new Runnable() {
            @Override
            public void run() {
                for (int i = 0; i < 10; i++) {
                    say.printC();
                }
            }
        }).start();

    }

}

class HiSay{
    private int flag = 1;
    Lock lock = new ReentrantLock();
    Condition condition1 = lock.newCondition();
    Condition condition2 = lock.newCondition();
    Condition condition3 = lock.newCondition();
    public void printA(){
        lock.lock();
        try {
            while (flag != 1){
                condition1.await();
            }
            System.out.println("A");
            flag ++;
            condition2.signal();
        }catch (Exception e){
            e.printStackTrace();
        }finally {
            lock.unlock();
        }
    }
    public void printB(){
        lock.lock();
        try {
            while (flag != 2){
                condition2.await();
            }
            System.out.println("B");
            flag++;
            condition3.signal();
        }catch (Exception e){
            e.printStackTrace();
        }finally {
            lock.unlock();
        }
    }
    public void printC(){
        lock.lock();
        try {
            while (flag != 3){
                condition3.await();
            }
            System.out.println("C");
            flag = 1;
            condition1.signal();
        }catch (Exception e){
            e.printStackTrace();
        }finally {
            lock.unlock();
        }
    }
}

~~~

### 3.4 synchronized关键字和ReentrantLock 的区别

#### 1 都是可重入锁

**“可重入锁”** 指的是**自己可以再次获取自己的内部锁**。比如一个线程获得了某个对象的锁，此时这个对象锁还没有释放，**当其再次想要获取这个对象的锁的时候还是可以获取的**，如果**不可锁重入的话，就会造成死锁**。**同一个线程每次获取锁，锁的计数器都自增 1**，所以要等到锁的计数器下降为 0 时才能释放锁。

#### 2 synchronized 依赖于 JVM 而 ReentrantLock 依赖于 API

#### 3 ReentrantLock 比 synchronized 增加了一些高级功能

- **等待可中断** : `ReentrantLock`提供了一种能够中断等待锁的线程的机制，通过 `lock.lockInterruptibly()` 来实现这个机制。也就是说**正在等待的线程可以选择放弃等待**，改为处理其他事情。
- **可实现公平锁** : `ReentrantLock`可以**指定是公平锁还是非公平锁**。而`synchronized`只能是**非公平锁**。所谓的公平锁就是先等待的线程先获得锁。`ReentrantLock`默认情况是非公平的，可以通过 `ReentrantLock`类的`ReentrantLock(boolean fair)`构造方法来制定是否是公平的。
- **可实现选择性通知（锁可以绑定多个条件）**: `synchronized`关键字与`wait()`和`notify()`/`notifyAll()`方法相结合可以实现等待/通知机制。`ReentrantLock`类当然也可以实现，但是需要借助于`Condition`接口与`newCondition()`方法。

* **Synchronized 适合锁少量的代码同步问题，Lock 适合锁大量的同步代码！**  

### 

# 4 生产者消费者问题也就是Condition的应用

## 1 使用Synchronized关键字实现的

```java
//判断等待 业务 通知
class Data{
    private int number = 0;

    //+1
    public synchronized  void increment() throws InterruptedException {
        while (number!=0 ){
            //等待
            this.wait();
        }
        number++;
        System.out.println(Thread.currentThread().getName()+"==>"+number);
        //通知其他线程，我+1完毕
        this.notify();
    }

    public synchronized void decrement() throws InterruptedException {
        while (number == 0){
            //等待
            this.wait();
        }
        number--;
        System.out.println(Thread.currentThread().getName()+"==>"+number);
        //通知其他线程，我-1完毕
        this.notify();
    }
}
```



## 2 使用锁实现的消费者生产者模型，不能实现对应线程的唤醒

~~~java


//利用锁实现的消费者生产者模型，不能实现对应线程的唤醒，
//判断等待 业务 通知
class Data2{
    private int number = 0;
    Lock lock = new ReentrantLock();
    Condition condition = lock.newCondition();
    //+1
    public  void increment() throws InterruptedException {
        lock.lock();
        try{
            while (number!=0 ){
                //等待
                condition.await();
            }
            number++;
            System.out.println(Thread.currentThread().getName()+"==>"+number);
            //通知其他线程，我+1完毕
            condition.signalAll();
        }catch (Exception e){
            e.printStackTrace();
        }finally {
            lock.unlock();
        }


    }
    //-1
    public  void decrement() throws InterruptedException {
        lock.lock();
        try{
            while (number==0 ){
                //等待
                condition.await();
            }
            number--;
            System.out.println(Thread.currentThread().getName()+"==>"+number);
            //通知其他线程，我+1完毕
            condition.signalAll();
        }catch (Exception e){
            e.printStackTrace();
        }finally {
            lock.unlock();
        }
    }
}
~~~

###  3 Condition实现对应线程的唤醒

~~~java
public class test3 {
    public static void main(String[] args) {
        Data3 data = new Data3();
        new Thread(()->{
            for (int i = 0; i < 10; i++) {
                data.printA();
            }
        },"A").start();
        new Thread(()->{
            for (int i = 0; i <10 ; i++) {
                data.printB();
            }
        },"B").start();
        new Thread(()->{
            for (int i = 0; i < 10; i++) {
                data.printC();
            }
        },"C").start();
    }
}
//精准唤醒资源类
class Data3{
    private int number = 1;  //1=>A  2=>B  3=>C
    private Lock lock = new ReentrantLock();
    private Condition condition1 = lock.newCondition();
    private Condition condition2 = lock.newCondition();
    private Condition condition3 = lock.newCondition();

    public void printA(){
        lock.lock();
        try{
            while (number!=1){
                condition1.await();
            }
            System.out.println(Thread.currentThread().getName()+"==>"+number);
            //唤醒指定的线程
            number = 2;
            condition2.signal();
        }catch (Exception e){
            e.printStackTrace();
        }finally {
            lock.unlock();
        }
    }
    public void printB(){
        lock.lock();
        try{
            while (number!=2){
                condition2.await();
            }
            System.out.println(Thread.currentThread().getName()+"==>"+number);
            //唤醒指定的线程
            number = 3;
            condition3.signal();
        }catch (Exception e){
            e.printStackTrace();
        }finally {
            lock.unlock();
        }

    }
    public void printC(){
        lock.lock();
        try {
            while (number!=3){
                condition3.await();
            }
            System.out.println(Thread.currentThread().getName()+"==>"+number);
            //唤醒指定的线程
            number = 1;
            condition1.signal();

        }catch (Exception e){
            e.printStackTrace();
        }finally {
            lock.unlock();
        }
    }

    //生产线
}

~~~

# 5 深入理解Synchronized关键字锁的作用

## 5.1锁普通方法

>锁的是对象,一个对象一把锁
>
>同一个对象的多个锁普通方法，谁先拿到谁先执行
>
>多个对象不影响，按时间，谁先到谁先执行

### 5.1.1 锁普通方法

> 锁的是对象
>
>  一个对象，谁先拿到锁谁先运行，前面拿到锁的方法运行完之后，后面的方法才能运行

~~~java
//普通方法上锁，谁先拿到谁先执行
public class Lock1 {
    public static void main(String[] args) {
        Data data = new Data();
        new Thread(new Runnable() {
            @Override
            public void run() {
                data.printA();
            }
        }).start();
        //延时1s
        try {
            TimeUnit.SECONDS.sleep(1);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        new Thread(new Runnable() {
            @Override
            public void run() {
                data.printB();

            }
        }).start();
    }
}
class Data{
    //普通方法上锁，谁先拿到谁先执行
    public synchronized void printA(){
        System.out.println("A");
    }
    public synchronized void printB(){
        System.out.println("B");
    }
}

~~~

输出

~~~
A
B
~~~

修改`printA`方法延时更长输出仍然不变

~~~java
class Data{
    //普通方法上锁，谁先拿到谁先执行
    public synchronized void printA(){
        try {
            TimeUnit.SECONDS.sleep(10);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println("A");
    }
    public synchronized void printB(){
        System.out.println("B");
    }
}
~~~



### 5.1.2 没有锁的普通方法

>一个对象，谁先拿到锁谁先运行，没有锁的方法直接运行

看延时时间

```java
public class Lock2 {
    public static void main(String[] args) {
        Data1 data = new Data1();
        new Thread(new Runnable() {
            @Override
            public void run() {
                data.printA();
            }
        }).start();
        //延时1s
        try {
            TimeUnit.SECONDS.sleep(1);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        new Thread(new Runnable() {
            @Override
            public void run() {
                data.printC();
            }
        }).start();
    }
}
class Data1{
    //普通方法上锁，谁先拿到谁先执行
    public synchronized void printA(){
        try {
            TimeUnit.SECONDS.sleep(10);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println("A");
    }
    public synchronized void printB(){
        System.out.println("B");
    }
    
    //没有锁，所以只看延时时间
    public void printC(){
        System.out.println("C");
    }
}
```

输出

~~~
C
A
~~~



### 5.1.3 两个对象的普通方法锁

>如果是一个对象，谁先拿到锁谁先运行
>
>这里是两个对象，每个对象都有自己的锁，
>
>

```java
public class Lock3 {
    public static void main(String[] args) {
        Data2 data = new Data2();
        Data2 data1 = new Data2();
        new Thread(new Runnable() {
            @Override
            public void run() {
                data.printA();
            }
        }).start();
        //延时1s
        try {
            TimeUnit.SECONDS.sleep(1);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        new Thread(new Runnable() {
            @Override
            public void run() {
                data1.printB();
            }
        }).start();
    }
}

class Data2{
    //普通方法上锁，谁先拿到谁先执行
    public synchronized void printA(){
        try {
            TimeUnit.SECONDS.sleep(4);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println("A");
    }
    public synchronized void printB(){
        System.out.println("B");
    }
}
```

输出

~~~
B
A
~~~



## 5.2 锁静态方法

> 锁的是类
>
> 一个对象两个对象对结果没影响

### 5.2.1 一个对象锁静态方法

```java
public class Lock4 {
    public static void main(String[] args) {
        Data3 data = new Data3();
        Data3 data1 = new Data3();
        new Thread(new Runnable() {
            @Override
            public void run() {
                data.printA();
            }
        }).start();
        //延时1s
        try {
            TimeUnit.SECONDS.sleep(1);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        new Thread(new Runnable() {
            @Override
            public void run() {
                data1.printB();
            }
        }).start();
    }
}
class Data3{
    //普通方法上锁，谁先拿到谁先执行
    public static synchronized void printA(){
        try {
            TimeUnit.SECONDS.sleep(4);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println("A");
    }
    public static synchronized void printB(){
        System.out.println("B");
    }

}
```

输出

~~~
A
B
~~~

### 5.2.2 一个静态方法锁一个普通方法锁

>调用静态方法锁的时候锁的是类
>
>调用普通方法锁的时候锁的是对象
>
>所以在下面的例子中，第二个方法也可以获得锁。

```java
public class Lock5 {
    public static void main(String[] args) {
        Data4 data = new Data4();
        Data4 data1 = new Data4();
        new Thread(new Runnable() {
            @Override
            public void run() {
                data.printA();
            }
        }).start();
        //延时1s
        try {
            TimeUnit.SECONDS.sleep(1);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        new Thread(new Runnable() {
            @Override
            public void run() {
                data.printB();
            }
        }).start();
    }
}
class Data4{
    //普通方法上锁，谁先拿到谁先执行
    public static synchronized void printA(){
        try {
            TimeUnit.SECONDS.sleep(4);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println("A");
    }
    public synchronized void printB(){
        System.out.println("B");
    }
}
```

输出

~~~
B
A
~~~



# 6 Callable接口

![image-20220303091801151](C:\Users\jinhu\AppData\Roaming\Typora\typora-user-images\image-20220303091801151.png)

* 带返回值的线程任务
* 可以抛出异常
* 实现方法不同，run()/call()



## 6.1 简介

Runnable 封装一个异步运行的任务，可以把它想象成为一个没有参数和返回值的异步方法。Callable 与 Runnable 类似， 但是有返回值。Callable 接口是一个参数化的类型， 只有一个方法 call。  

~~~java
@FunctionalInterface
public interface Callable<V> {
    /**
     * Computes a result, or throws an exception if unable to do so.
     *
     * @return computed result
     * @throws Exception if unable to compute a result
     */
    V call() throws Exception;
}
~~~





## 6.2 使用方法

![image-20220303092247859](C:\Users\jinhu\AppData\Roaming\Typora\typora-user-images\image-20220303092247859.png)

![image-20220303092312804](C:\Users\jinhu\AppData\Roaming\Typora\typora-user-images\image-20220303092312804.png)

**通常情况下搭配FutureTask使用。其中FutureTask的get方法是阻塞的，在结果返回前会一直等待。**

~~~java
public class CallableTest {
    public static void main(String[] args) {
        FutureTask<Integer> futureTask = new FutureTask(new CallableThread());
        new Thread(futureTask,"A").start();

        if(futureTask.isDone()){
            System.out.println("over");
            try {
                Integer result = futureTask.get();
                System.out.println(result);
            } catch (InterruptedException e) {
                e.printStackTrace();
            } catch (ExecutionException e) {
                e.printStackTrace();
            }
        }
        try {
            Integer result = futureTask.get();
            System.out.println(result);
        } catch (InterruptedException e) {
            e.printStackTrace();
        } catch (ExecutionException e) {
            e.printStackTrace();
        }

    }

}

class CallableThread implements Callable<Integer>{
    @Override
    public Integer call() throws Exception {
        System.out.println("call()"); // 会打印几个call
        int sum = 0;
        for (int i = 0; i < 10 ; i++) {
            sum +=  i;
        }
        return sum;
    }
}
~~~

# 7 Future接口 异步回调

Future 保存异步计算的结果。可以启动一个计算，将 Future 对象交给某个线程，然后忘掉它。Future 对象的所有者在结果计算好之后就可以获得它。  

## 7.1 Future接口介绍

FutureTask就实现了Future接口。

~~~java
public interface Future<V> {

    /**
     * Attempts to cancel execution of this task.  This attempt will
     * fail if the task has already completed, has already been cancelled,
     * or could not be cancelled for some other reason. If successful,
     * and this task has not started when {@code cancel} is called,
     * this task should never run.  If the task has already started,
     * then the {@code mayInterruptIfRunning} parameter determines
     * whether the thread executing this task should be interrupted in
     * an attempt to stop the task.
     * 如果计算还没有开始，它被取消且不再开始。如果计算处于运行之中，
     * 那么如果 mayInterruptIfRunning 参数为 true, 它就被中断。
     */
    boolean cancel(boolean mayInterruptIfRunning);

    /**
     * Returns {@code true} if this task was cancelled before it completed
     * normally.
     *
     * @return {@code true} if this task was cancelled before it completed
     */
    boolean isCancelled();

    /**
     * Returns {@code true} if this task completed.
     *
     * Completion may be due to normal termination, an exception, or
     * cancellation -- in all of these cases, this method will return
     * {@code true}.
     *
     * @return {@code true} if this task completed
     */
    boolean isDone();

    /**
     * Waits if necessary for the computation to complete, and then
     * retrieves its result.
     *	 阻塞直到计算完成
     * @return the computed result
     * @throws CancellationException if the computation was cancelled
     * @throws ExecutionException if the computation threw an
     * exception
     * @throws InterruptedException if the current thread was interrupted
     * while waiting
     */
    V get() throws InterruptedException, ExecutionException;

    /**
     * Waits if necessary for at most the given time for the computation
     * to complete, and then retrieves its result, if available.
     * 阻塞设置的时间，超时抛出异常
     * @param timeout the maximum time to wait
     * @param unit the time unit of the timeout argument
     * @return the computed result
     * @throws CancellationException if the computation was cancelled
     * @throws ExecutionException if the computation threw an
     * exception
     * @throws InterruptedException if the current thread was interrupted
     * while waiting
     * @throws TimeoutException if the wait timed out
     */
    V get(long timeout, TimeUnit unit)
        throws InterruptedException, ExecutionException, TimeoutException;
}
~~~

## 7.2 CompletableFuture使用

![image-20220303100654309](C:\Users\jinhu\AppData\Roaming\Typora\typora-user-images\image-20220303100654309.png)

### 示例代码

~~~java
public class FutureTest {
    public static void main(String[] args) throws ExecutionException, InterruptedException {
        //使用CompletableFuture类的静态方法supplyAsync创建一个线程
        //supplyAsync 有返回值的异步回调
        //串行执行
        CompletableFuture<Integer> future =  CompletableFuture.supplyAsync(()->{
            int i = 1024;
            int j = 0;
            return 1024;
        });

        //函数式接口,参数为上一阶段的结果
        CompletableFuture<Integer> future1 =  future.thenApplyAsync((t)->{
            System.out.println("result >>" + t);
            return 20;
        });
        future1.thenAccept((t)->{
            System.out.println("future1  >>" +t);
        });

        System.out.println(future1.whenComplete((t,u)->{
            System.out.println("t==>"+t);   //正确返回结果
            System.out.println("u==>"+u);   //错误信息
        }).exceptionally((e)->{
            //异常处理，必须有返回值
            System.out.println(e.getMessage());
            return -1;
        }).get());

        //并行任务
        CompletableFuture<String> future2 =  CompletableFuture.supplyAsync(()->{
            try {
                TimeUnit.SECONDS.sleep(3);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println("并行任务1");
            return "1024";
        });
        CompletableFuture<String> future3 =  CompletableFuture.supplyAsync(()->{
            System.out.println("并行任务2");
            return "100";
        });
        //合并上面两个任务,以上两个任务有一个返回就可以继续下一步
        CompletableFuture<Object> future4 = CompletableFuture.anyOf(future2,future3);
        CompletableFuture<String> future5 = future4.thenApplyAsync((t)->{
            System.out.println("并行任务后的串行任务"+t);
            return "over";
        });
        System.out.println(future5.whenComplete((t,u)->{
            System.out.println("t==>"+t);   //正确返回结果
            System.out.println("u==>"+u);   //错误信息
        }).exceptionally((e)->{
            //异常处理，必须有返回值
            System.out.println(e.getMessage());
            return "-1";
        }).get());
    }
}
~~~

# 8 同步器 线程管理辅助类

## 8.1 常见的同步器

![image-20220303104604102](C:\Users\jinhu\AppData\Roaming\Typora\typora-user-images\image-20220303104604102.png)

## 8.2 CountDownLatch

* `countDownLatch`这个类使一个线程等待其他线程各自执行完毕后再执行。

* 是通过一个计数器来实现的，计数器的初始值是线程的数量。每当一个线程执行完毕后，计数器的值就-1，当计数器的值为0时，表示所有线程都执行完毕，然后在闭锁上等待的线程就可以恢复工作了



**countDownLatch是一个计数器，线程完成一个记录一个，计数器递减，只能只用一次**

### 1 所有方法

![image-20220303111200994](C:\Users\jinhu\AppData\Roaming\Typora\typora-user-images\image-20220303111200994.png)

### 2 使用方法

>一组任务同时开始，防止在发出信号前有子任务先运行
>
>一组任务都完成时才能进行下面的任务。

![image-20220303105301064](C:\Users\jinhu\AppData\Roaming\Typora\typora-user-images\image-20220303105301064.png)

示例代码

```java
public class CountDownLatchTest {
    public static void main(String[] args) {
        CountDownLatch startLatch = new CountDownLatch(1);
        CountDownLatch doneLatch  = new CountDownLatch(20);
        //直接使用Thread类创建线程
        for (int i = 10; i < 20 ; i++) {
            new  Thread(new Runnable() {
                @Override
                public void run() {
                    try {
                        startLatch.await();
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                    System.out.println(Thread.currentThread().getName()+" is run.");
                    doneLatch.countDown();
                }
            },"Thread "+ i).start();
        }


        for (int i = 0; i < 10; i++) {
            new Thread(new Resource(startLatch,doneLatch),String.valueOf(i)).start();
        }
        System.out.println("begin run");
        startLatch.countDown();
        try {
            doneLatch.await();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println("over");

    }


}
//注意这里的资源类需要定义final类型的CountDownLatch
class Resource implements Runnable{
    private final CountDownLatch startLatch;
    private final CountDownLatch doneLatch;
    public Resource(CountDownLatch startLatch, CountDownLatch doneLatch){
        this.startLatch = startLatch;
        this.doneLatch  = doneLatch;
    }
    @Override
    public void run() {
        try {
            startLatch.await();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println(Thread.currentThread().getName()+" is run.");
        doneLatch.countDown();
    }
}
```

## 8.3 CyclicBarrier  

`CyclicBarrier`的计数器更像一个阀门，需要所有线程都到达，然后继续执行，计数器递增，提供reset功能，可以多次使用.

![image-20220303111557357](C:\Users\jinhu\AppData\Roaming\Typora\typora-user-images\image-20220303111557357.png)



#### 示例代码

~~~java
public class CyclicBarrierTest {
    public static void main(String[] args) {
        CyclicBarrier cyclicBarrier = new CyclicBarrier(7, new Runnable() {
            @Override
            public void run() {
                System.out.println("over");
            }
        });
        for (int i = 0; i < 7; i++) {
            new Thread(new Runnable() {
                @Override
                public void run() {
                    System.out.println(Thread.currentThread().getName()+" is run.");
                    try {
                        cyclicBarrier.await();
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    } catch (BrokenBarrierException e) {
                        e.printStackTrace();
                    }
                }
            },String.valueOf(i)).start();
        }
        cyclicBarrier.reset();
        test(cyclicBarrier);

    }
    public static void test(CyclicBarrier cyclicBarrier){
        for (int i = 0; i < 7; i++) {
            new Thread(new Runnable() {
                @Override
                public void run() {
                    System.out.println(Thread.currentThread().getName()+" is run.");
                    try {
                        cyclicBarrier.await();
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    } catch (BrokenBarrierException e) {
                        e.printStackTrace();
                    }
                }
            },String.valueOf(i)).start();
        }
    }
}
~~~

## 8.4 Semaphore  信号量

### 1 构造方法

> - permits 表示许可线程的数量
> - fair 表示公平性，如果这个设为 true 的话，下次执行的线程会是等待最久的线程

```java

public Semaphore(int permits) {
    sync = new NonfairSync(permits);
}

/**
 * Creates a {@code Semaphore} with the given number of
 * permits and the given fairness setting.
 *
 * @param permits the initial number of permits available.
 *        This value may be negative, in which case releases
 *        must occur before any acquires will be granted.
 * @param fair {@code true} if this semaphore will guarantee
 *        first-in first-out granting of permits under contention,
 *        else {@code false}
 */
public Semaphore(int permits, boolean fair) {
    sync = fair ? new FairSync(permits) : new NonfairSync(permits);
}
```

### 2 重要方法

~~~java
//阻塞并获取许可
public void acquire() throws InterruptedException
//释放许可
public void release()
~~~

### 3 基本使用

**使用场景：**多个线程同时执行，但是限制同时执行的线程数量为N 个。

```java
public class SemaphoreTest {
    public static void main(String[] args) {
        Semaphore semaphore = new Semaphore(3);
        for (int i = 0; i < 10; i++) {
            new Thread(new Worker(semaphore,i)).start();
        }

    }
}

class Worker implements Runnable{
    private final Semaphore semaphore;
    private int name;
    public Worker(Semaphore semaphore,int name){
        this.semaphore = semaphore;
        this.name = name;
    }

    @Override
    public void run() {
        try {
            semaphore.acquire();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        System.out.println(name + " acquire");
        try {
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        //System.out.println(name + "is use semaphore.");
        System.out.println(name + " release");
        semaphore.release();

    }
}
```

# 9 读写锁 ReadWriteLock  

ReadWriteLock管理一组锁，一个是只读的锁，一个是写锁。

> 独占锁（写锁） 一次只能被一个线程占有
> 共享锁（读锁） 多个线程可以同时占有  
>
> 读写锁的特点是：**同一时刻允许多个线程对共享资源进行读操作**；同一时刻只允许一个线程对共享资源进行写操作；**当进行写操作时，同一时刻其他线程的读操作会被阻塞**；**当进行读操作时，同一时刻所有线程的写操作会被阻塞**。对于读锁而言，由于**同一时刻可以允许多个线程访问共享资源，进行读操作**，因此称它为共享锁；而对于写锁而言，同一时刻只允许一个线程访问共享资源，进行写操作，因此称它为排他锁。
>
> 当**有读锁时，写锁就不能获得**；而当有写锁时，除了获得写锁的这个线程可以获得读锁外，其他线程不能获得读锁
> 

读可以被多线程同时读，写的时候只能有一个线程去写。

~~~java
public interface ReadWriteLock {
    /**
     * Returns the lock used for reading.
     *
     * @return the lock used for reading
     */
    Lock readLock();

    /**
     * Returns the lock used for writing.
     *
     * @return the lock used for writing
     */
    Lock writeLock();
}
~~~

## 9.1 ReentrantReadWriteLock类

`ReentrantReadWriteLock`类，顾名思义，是一种读写锁，它是[ReadWriteLock接口](https://segmentfault.com/a/1190000015562196#articleHeader6)的直接实现，该类在内部实现了具体**独占锁**特点的写锁，以及具有**共享锁**特点的读锁，和`ReentrantLock`一样，`ReentrantReadWriteLock`类也是通过定义内部类实现AQS框架的API来实现独占/共享的功能。



`ReentrantReadWriteLock`类有两个内部嵌套类`ReadLock`和`WriteLock`，这两个内部类的实例会在`ReentrantReadWriteLock`类的构造器中创建，并通过`ReentrantReadWriteLock`类的`readLock()`和`writeLock()`方法访问。

### 9.1.1 支持公平非公平策略

与`ReadWriteLock`类一样，`ReentrantReadWriteLock`对象在构造时，可以传入参数指定是公平锁还是非公平锁。**默认为非公平锁**。

~~~java
/**
     * Creates a new {@code ReentrantReadWriteLock} with
     * default (nonfair) ordering properties.
     */
    public ReentrantReadWriteLock() {
        this(false);
    }

    /**
     * Creates a new {@code ReentrantReadWriteLock} with
     * the given fairness policy.
     *
     * @param fair {@code true} if this lock should use a fair ordering policy
     */
    public ReentrantReadWriteLock(boolean fair) {
        sync = fair ? new FairSync() : new NonfairSync();
        readerLock = new ReadLock(this);
        writerLock = new WriteLock(this);
    }
~~~

### 9.1.2 支持锁重入

- 同一读线程在获取了读锁后还可以获取读锁；
- 同一写线程在获取了写锁之后既可以再次获取写锁又可以获取读锁

### 9.1.3 支持锁降级

所谓锁降级，就是：先获取写锁，然后获取读锁，最后释放写锁，这样写锁就降级成了读锁。但是，读锁不能升级到写锁。简言之，就是：

> 写锁可以降级成读锁，读锁不能升级成写锁。

### 9.1.4 Condition条件支持

`ReentrantReadWriteLock`的内部读锁类、写锁类实现了Lock接口，所以可以通过`newCondition()`方法获取Condition对象。但是这里要注意，**读锁是没法获取Condition对象**的，读锁调用`newCondition() `方法会直接抛出`UnsupportedOperationException`。

> 我们知道，condition的作用其实是对Object类的`wait()`和`notify()`的增强，是为了让线程在指定对象上等待，是一种线程之间进行协调的工具。
> 当线程调用condition对象的`await`方法时，必须拿到和这个condition对象关联的锁。由于线程对读锁的访问是不受限制的（在写锁未被占用的情况下），那么即使拿到了和读锁关联的condition对象也是没有意义的，因为读线程之前不需要进行协调。

### 9.1.5 使用实例

~~~java
public class ReadWriteLockTest {
    public static void main(String[] args) {
        RWMap rwMap = new RWMap();
        for (int i = 0; i < 10; i++) {
            int finalI = i;
            new Thread(new Runnable() {
                @Override
                public void run() {
                    System.out.println("写入>>"+finalI);
                    rwMap.put(String.valueOf(finalI),String.valueOf(finalI));
                }
            }).start();
        }
        try {
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        for (int i = 0; i < 10; i++) {
            int finalI = i;
            new Thread(new Runnable() {
                @Override
                public void run() {
                    System.out.println(rwMap.get(String.valueOf(finalI)));
                }
            }).start();
        }

    }
}
class RWMap{
    private final Map<String,String> map = new HashMap<>();
    private final ReentrantReadWriteLock reentrantReadWriteLock = new ReentrantReadWriteLock();
    private final Lock read = reentrantReadWriteLock.readLock();
    private final Lock write = reentrantReadWriteLock.writeLock();

    public String get(String key){
        read.lock();
        try{
            return map.get(key);
        }catch (Exception e){
            e.printStackTrace();
        }finally {
            read.unlock();
        }
        return key;
    }

    public void put(String key,String value){
        write.lock();
        try{
            map.put(key,value);
        }catch (Exception e){
            e.printStackTrace();
        }finally {
            write.unlock();
        }
    }

}
~~~

# 10 阻塞队列

## 10.1 方法总结

![image-20220303202400700](C:\Users\jinhu\AppData\Roaming\Typora\typora-user-images\image-20220303202400700.png)

### 抛出异常

~~~java
//没有空间或者队列为空时抛出异常
boolean add(e)
E remove()
E element()

~~~

### 返回特殊值

~~~java
//返回false
boolean offer(e)
//返回null
E poll()
//返回null
E peek()
~~~

### 阻塞

~~~java
void put(e)
E take()
~~~

### 超时

~~~java
//返回false
boolean offer(e,time,unit)
//返回null
E poll(time,unit)
~~~





### 1 `ArrayBlockingQueue`

　　基于数组的阻塞队列实现，在`ArrayBlockingQueue`内部，维护了一个定长数组，以便缓存队列中的数据对象，这是一个常用的阻塞队列，除了一个定长数组外，`ArrayBlockingQueue`内部还保存着两个整形变量，分别标识着队列的头部和尾部在数组中的位置。

　　ArrayBlockingQueue在**生产者放入数据和消费者获取数据，都是共用同一个锁对象**，由此也意味着两者无法真正并行运行，这点尤其不同于`LinkedBlockingQueue`；按照实现原理来分析，ArrayBlockingQueue完全可以采用分离锁，从而实现生产者和消费者操作的完全并行运行。Doug Lea之所以没这样去做，也许是因为ArrayBlockingQueue的数据写入和获取操作已经足够轻巧，以至于引入独立的锁机制，除了给代码带来额外的复杂性外，其在性能上完全占不到任何便宜。 ArrayBlockingQueue和LinkedBlockingQueue间还有一个明显的不同之处在于，前者在插入或删除元素时不会产生或销毁任何额外的对象实例，而后者则会生成一个额外的Node对象。这在长时间内需要高效并发地处理大批量数据的系统中，其对于GC的影响还是存在一定的区别。而`在创建ArrayBlockingQueue时，我们还可以控制对象的内部锁是否采用公平锁，默认采用非公平锁。`

### 2.`**LinkedBlockingQueue**`

　　基于链表的阻塞队列，同ArrayListBlockingQueue类似，其内部也维持着一个数据缓冲队列（该队列由一个链表构成），`当生产者往队列中放入一个数据时，队列会从生产者手中获取数据，并缓存在队列内部，而生产者立即返回；`只有当`队列缓冲区达到最大值缓存容量时（LinkedBlockingQueue可以通过构造函数指定该值），才会阻塞生产者队列`，直到消费者从队列中消费掉一份数据，生产者线程会被唤醒，反之对于消费者这端的处理也基于同样的原理。而LinkedBlockingQueue之所以能够高效的处理并发数据，还因为其对于`生产者端和消费者端分别采用了独立的锁`来控制数据同步，这也意味着在高并发的情况下生产者和消费者可以并行地操作队列中的数据，以此来提高整个队列的并发性能。

　　**注意**，如果构造一个LinkedBlockingQueue对象，而没有指定其容量大小，LinkedBlockingQueue会默认一个类似无限大小的容量（Integer.MAX_VALUE），这样的话，如果生产者的速度一旦大于消费者的速度，也许还没有等到队列满阻塞产生，系统内存就有可能已被消耗殆尽了。

~~~java
public class BlockQueueTest {
    public static void main(String[] args) throws InterruptedException {
        // 声明一个容量为10的缓存队列
        BlockingQueue<String> queue = new LinkedBlockingQueue<String>(10);

        //new了三个生产者和一个消费者
        Producer producer1 = new Producer(queue);
        Producer producer2 = new Producer(queue);
        Producer producer3 = new Producer(queue);
        Consumer consumer = new Consumer(queue);

        // 借助Executors
        ExecutorService service = Executors.newCachedThreadPool();
        // 启动线程
        service.execute(producer1);
        service.execute(producer2);
        service.execute(producer3);
        service.execute(consumer);

        // 执行10s
        Thread.sleep(10 * 1000);
        producer1.stop();
        producer2.stop();
        producer3.stop();

        Thread.sleep(2000);
        // 退出Executor
        service.shutdown();
    }
}

class Producer implements Runnable {

    private volatile boolean  isRunning = true;//是否在运行标志
    private BlockingQueue queue;//阻塞队列
    private static AtomicInteger count = new AtomicInteger();//自动更新的值
    private static final int DEFAULT_RANGE_FOR_SLEEP = 1000;

    //构造函数
    public Producer(BlockingQueue queue) {
        this.queue = queue;
    }

    public void run() {
        String data = null;
        Random r = new Random();

        System.out.println("启动生产者线程！");
        try {
            while (isRunning) {
                System.out.println("正在生产数据...");
                Thread.sleep(r.nextInt(DEFAULT_RANGE_FOR_SLEEP));//取0~DEFAULT_RANGE_FOR_SLEEP值的一个随机数

                data = "data:" + count.incrementAndGet();//以原子方式将count当前值加1
                System.out.println("将数据：" + data + "放入队列...");
                if (!queue.offer(data, 2, TimeUnit.SECONDS)) {//设定的等待时间为2s，如果超过2s还没加进去返回true
                    System.out.println("放入数据失败：" + data);
                }
            }
        } catch (InterruptedException e) {
            e.printStackTrace();
            Thread.currentThread().interrupt();
        } finally {
            System.out.println("退出生产者线程！");
        }
    }

    public void stop() {
        isRunning = false;
    }
}

class Consumer implements Runnable {

    private BlockingQueue<String> queue;
    private static final int DEFAULT_RANGE_FOR_SLEEP = 1000;

    //构造函数
    public Consumer(BlockingQueue<String> queue) {
        this.queue = queue;
    }

    public void run() {
        System.out.println("启动消费者线程！");
        Random r = new Random();
        boolean isRunning = true;
        try {
            while (isRunning) {
                System.out.println("正从队列获取数据...");
                String data = queue.poll(2, TimeUnit.SECONDS);//有数据时直接从队列的队首取走，无数据时阻塞，在2s内有数据，取走，超过2s还没数据，返回失败
                if (null != data) {
                    System.out.println("拿到数据：" + data);
                    System.out.println("正在消费数据：" + data);
                    Thread.sleep(r.nextInt(DEFAULT_RANGE_FOR_SLEEP));
                } else {
                    // 超过2s还没数据，认为所有生产线程都已经退出，自动退出消费线程。
                    isRunning = false;
                }
            }
        } catch (InterruptedException e) {
            e.printStackTrace();
            Thread.currentThread().interrupt();
        } finally {
            System.out.println("退出消费者线程！");
        }
    }


}
~~~



# 11 线程池

**线程池：三大方法、7大参数、4种拒绝策略**  

> 线程池做的工作主要是**控制运行的线程的数量**，处理过程中**将任务放入队列**，然后在线程创建后
> 启动这些任务，如果线程数量超过了最大数量超出数量的线程排队等候，等其它线程执行完毕，
> 再从队列中取出任务来执行。 他的主要特点为： **线程复用； 控制最大并发数； 管理线程**。  

## 11.1 线程池的组成部分

1. **线程池管理器**：用于创建并管理线程池
2. **工作线程**：线程池中的线程
3. **任务接口**：每个任务必须实现的接口，用于工作线程调度其运行。
4. **任务队列**：用于存放待处理的任务，提供一种缓冲机制  

**优点**

* 降低资源消耗
* 提高响应速度
* 方便管理



Java 中的线程池是通过 Executor 框架实现的，该框架中用到了 `Executor， Executors，ExecutorService， ThreadPoolExecutor ， Callable 和 Future、 FutureTask` 这几个类。  

![image-20220303211826365](C:\Users\jinhu\AppData\Roaming\Typora\typora-user-images\image-20220303211826365.png)





![任务的执行相关接口](https://github.com/FufuJIN/JavaGuide/raw/master/docs/java/multi-thread/images/java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/%E4%BB%BB%E5%8A%A1%E7%9A%84%E6%89%A7%E8%A1%8C%E7%9B%B8%E5%85%B3%E6%8E%A5%E5%8F%A3.png)

**注意事项**

![image-20220303212207191](C:\Users\jinhu\AppData\Roaming\Typora\typora-user-images\image-20220303212207191.png)

![image-20220303212305585](C:\Users\jinhu\AppData\Roaming\Typora\typora-user-images\image-20220303212305585.png)



## 11.2 Executor 框架的使用示意图

![Executor 框架的使用示意图](https://github.com/FufuJIN/JavaGuide/raw/master/docs/java/multi-thread/images/java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/Executor%E6%A1%86%E6%9E%B6%E7%9A%84%E4%BD%BF%E7%94%A8%E7%A4%BA%E6%84%8F%E5%9B%BE.png)





1. **主线程首先要创建实现 `Runnable` 或者 `Callable` 接口的任务对象。**

2. **把创建完成的实现 `Runnable`/`Callable`接口的 对象直接交给 `ExecutorService` 执行**: `ExecutorService.execute（Runnable command）`）或者也可以把 `Runnable` 对象或`Callable` 对象提交给 `ExecutorService` 执行（`ExecutorService.submit（Runnable task）`或 `ExecutorService.submit（Callable <T> task）`）。

3. **如果执行 `ExecutorService.submit（…）`，`ExecutorService` 将返回一个实现`Future`接口的对象**（我们刚刚也提到过了执行 `execute()`方法和 `submit()`方法的区别，`submit()`会返回一个 `FutureTask 对象）。由于 FutureTask` 实现了 `Runnable`，我们也可以创建 `FutureTask`，然后直接交给 `ExecutorService` 执行。

4. **最后，主线程可以执行 `FutureTask.get()`方法来等待任务执行完成。主线程也可以执行 `FutureTask.cancel（boolean mayInterruptIfRunning）`来取消此任务的执行。**

   

> 执行任务的两种方法，
>
> ```java
> public interface ExecutorService extends Executor 
>  //submit是ExecutorService接口的方法
> <T> Future<T> submit(Callable<T> task);
> public interface Executor {
> 
>     /**
>      * Executes the given command at some time in the future.  The command
>      * may execute in a new thread, in a pooled thread, or in the calling
>      * thread, at the discretion of the {@code Executor} implementation.
>      *
>      * @param command the runnable task
>      * @throws RejectedExecutionException if this task cannot be
>      * accepted for execution
>      * @throws NullPointerException if command is null
>      */
>     void execute(Runnable command);
> }
> ```
>
> 1. **`execute()`方法用于提交不需要返回值的任务，所以无法判断任务是否被线程池执行成功与否；**
> 2. **`submit()`方法用于提交需要返回值的任务。线程池会返回一个 `Future` 类型的对象，通过这个 `Future` 对象可以判断任务是否执行成功**，

>关闭的方法
>
>#### 4.3.3 `shutdown()`VS`shutdownNow()`
>
>- **`shutdown（）`** :关闭线程池，线程池的状态变为 `SHUTDOWN`。线程池不再接受新任务了，但是队列里的任务得执行完毕。
>- **`shutdownNow（）`** :关闭线程池，线程的状态变为 `STOP`。线程池会终止当前正在运行的任务，并停止处理排队的任务并返回正在等待执行的 List。
>
>#### 4.3.2 `isTerminated()` VS `isShutdown()`
>
>- **`isShutDown`** 当调用 `shutdown()` 方法后返回为 true。
>- **`isTerminated`** 当调用 `shutdown()` 方法后，并且所有提交的任务完成后返回为 true

## 11.3 ThreadPoolExecutor 类简单介绍

Executor 创建线程

**创建单个线程的线程池**

~~~java
ExecutorService SingleThreadPool = Executors.newSingleThreadExecutor();
//源代码
public static ExecutorService newSingleThreadExecutor() {
    return new FinalizableDelegatedExecutorService
        (new ThreadPoolExecutor(1, 1,
                                0L, TimeUnit.MILLISECONDS,
                                new LinkedBlockingQueue<Runnable>()));
}
~~~

**创建固定线程数的线程池**

~~~java
ExecutorService fixedThreadPool = Executors.newFixedThreadPool(int n);
//源代码
public static ExecutorService newFixedThreadPool(int nThreads) {
    return new ThreadPoolExecutor(nThreads, nThreads,
                                  0L, TimeUnit.MILLISECONDS,
                                  new LinkedBlockingQueue<Runnable>());
}
~~~

**可变大小的线程池**

~~~java
ExecutorService cacheThreadPool = Executors.newCachedThreadPool();
       
public static ExecutorService newCachedThreadPool() {
        return new ThreadPoolExecutor(0, Integer.MAX_VALUE,
                                      60L, TimeUnit.SECONDS,
                                      new SynchronousQueue<Runnable>());
 }
~~~





~~~java
ExecutorService scheduledThreadPool = Executors.newScheduledThreadPool(3);
    public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize) {
        return new ScheduledThreadPoolExecutor(corePoolSize);
    }

public ScheduledThreadPoolExecutor(int corePoolSize) {
        super(corePoolSize, Integer.MAX_VALUE, 0, NANOSECONDS,
              new DelayedWorkQueue());
    }

public ThreadPoolExecutor(int corePoolSize,
                              int maximumPoolSize,
                              long keepAliveTime,
                              TimeUnit unit,
                              BlockingQueue<Runnable> workQueue) {
        this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,
             Executors.defaultThreadFactory(), defaultHandler);
    }
~~~





### 1 `ThreadPoolExecutor`类的构造函数

~~~java
//完整版的构造函数
    /**
     * Creates a new {@code ThreadPoolExecutor} with the given initial
     * parameters.
     *
     * @param corePoolSize the number of threads to keep in the pool, even
     *        if they are idle, unless {@code allowCoreThreadTimeOut} is set
     *        核心线程池大小
     * @param maximumPoolSize the maximum number of threads to allow in the
     *        pool
     *        最大线程池中线程数目大小
     * @param keepAliveTime when the number of threads is greater than
     *        the core, this is the maximum time that excess idle threads
     *        will wait for new tasks before terminating.
     *        当线程数大于核心线程时 线程等待调用的最大时间，超时就会释放
     * @param unit the time unit for the {@code keepAliveTime} argument
     *        超时时间单位
     * @param workQueue the queue to use for holding tasks before they are
     *        executed.  This queue will hold only the {@code Runnable}
     *        tasks submitted by the {@code execute} method.
     *        工作阻塞队列，用来保存将要执行的任务
     * @param threadFactory the factory to use when the executor
     *        creates a new thread
     *        线程工厂类，用于创建线程
     * @param handler the handler to use when execution is blocked
     *        because the thread bounds and queue capacities are reached
     *        拒绝策略
     * @throws IllegalArgumentException if one of the following holds:<br>
     *         {@code corePoolSize < 0}<br>
     *         {@code keepAliveTime < 0}<br>
     *         {@code maximumPoolSize <= 0}<br>
     *         {@code maximumPoolSize < corePoolSize}
     * @throws NullPointerException if {@code workQueue}
     *         or {@code threadFactory} or {@code handler} is null
     */
    public ThreadPoolExecutor(int corePoolSize,
                              int maximumPoolSize,
                              long keepAliveTime,
                              TimeUnit unit,
                              BlockingQueue<Runnable> workQueue,
                              ThreadFactory threadFactory,
                              RejectedExecutionHandler handler) {
        if (corePoolSize < 0 ||
            maximumPoolSize <= 0 ||
            maximumPoolSize < corePoolSize ||
            keepAliveTime < 0)
            throw new IllegalArgumentException();
        if (workQueue == null || threadFactory == null || handler == null)
            throw new NullPointerException();
        this.acc = System.getSecurityManager() == null ?
                null :
                AccessController.getContext();
        this.corePoolSize = corePoolSize;
        this.maximumPoolSize = maximumPoolSize;
        this.workQueue = workQueue;
        this.keepAliveTime = unit.toNanos(keepAliveTime);
        this.threadFactory = threadFactory;
        this.handler = handler;
    }
~~~

**参数分析**

**`ThreadPoolExecutor`的3个最重要的参数**

* **`corePoolSize`**： 核心线程数线程数定义了**最小可以同时运行的线程数量**。
* **`maximumPoolSize`**：**阻塞队列中存放的任务达到队列容量的时候**，**当前可以同时运行的线程数量变为最大线程数。**
* **`workQueue`**: 当新任务来的时候会**先判断当前运行的线程数量是否达到核心线程数**，如果**达到的话，新任务就会被存放在队列中**。

**任务先放核心线程，核心线程满了放任务队列，任务队列满了放最大核心线程**

![线程池各个参数的关系](https://github.com/FufuJIN/JavaGuide/raw/master/docs/java/multi-thread/images/java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%90%84%E4%B8%AA%E5%8F%82%E6%95%B0%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB.png)



**4种拒绝策略**

如果当前**同时运行的线程数量达到最大线程数量并且队列也已经被放满了任务**时，`ThreadPoolTaskExecutor` 定义一些策略:

- **`ThreadPoolExecutor.AbortPolicy`**：抛出 `RejectedExecutionException`来**拒绝新任务的处理。**
- **`ThreadPoolExecutor.CallerRunsPolicy`**：**调用执行自己的线程运行任务**，也就是直接在调用`execute`方法的线程中运行(`run`)被拒绝的任务，如果执行程序已关闭，则会丢弃该任务。因此这种策略会降低对于新任务提交速度，影响程序的整体性能。如果您的应用程序可以承受此延迟并且你要求任何一个任务请求都要被执行的话，你可以选择这个策略。
- **`ThreadPoolExecutor.DiscardPolicy`：** **不处理新任务，直接丢弃掉**。
- **`ThreadPoolExecutor.DiscardOldestPolicy`：** 此策略将**丢弃最早的未处理**的任务请求。

默认使用的是 `ThreadPoolExecutor.AbortPolicy`

### 2 ThreadPoolExecutor的使用

~~~java
public class ThreadPoolTest {
    public static void main(String[] args) {
  ArrayBlockingQueue<Runnable> arrayBlockingQueue = new ArrayBlockingQueue<Runnable>(10);
        ExecutorService threadPool = new ThreadPoolExecutor(5,
                                                 10,
                                                 10,
                                                 TimeUnit.SECONDS,
                                                 arrayBlockingQueue,
                                                 Executors.defaultThreadFactory(),
                                                 new ThreadPoolExecutor.AbortPolicy());
        try{
            for (int i = 0; i < 10; i++) {
                threadPool.execute(()->{
                    try {
                        TimeUnit.SECONDS.sleep(2);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                    System.out.println(Thread.currentThread().getName()+" is run.");
                });
            }
        }catch (Exception e){
            e.printStackTrace();
        }finally {
            //关闭线程池
            threadPool.shutdown();
        }
    }
}


~~~

![图解线程池实现原理](https://github.com/FufuJIN/JavaGuide/raw/master/docs/java/multi-thread/images/java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/%E5%9B%BE%E8%A7%A3%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86.png)

使用callable**接口**

```java
public class ThreadPoolTest {
    public static void main(String[] args) {
//        ExecutorService SingleThreadPool = Executors.newSingleThreadExecutor();
//        ExecutorService fixedThreadPool = Executors.newFixedThreadPool(3);
//        ExecutorService cacheThreadPool = Executors.newCachedThreadPool();
//        ExecutorService scheduledThreadPool = Executors.newScheduledThreadPool(3);
        ArrayBlockingQueue<Runnable> arrayBlockingQueue = new ArrayBlockingQueue<Runnable>(10);
        ExecutorService threadPool = new ThreadPoolExecutor(5,
                                                        10,
                                                        10,
                                                        TimeUnit.SECONDS,
                                                        arrayBlockingQueue,
                                                        Executors.defaultThreadFactory(),
                                                        new ThreadPoolExecutor.AbortPolicy());
        try{
            for (int i = 0; i < 10; i++) {
                threadPool.execute(()->{
                    try {
                        TimeUnit.SECONDS.sleep(2);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                    System.out.println(Thread.currentThread().getName()+" is run.");
                });
            }
            ArrayList<Future<String>> list = new ArrayList<>();
            for (int i = 0; i < 10; i++) {
                Future<String> future = threadPool.submit(new Worker());
                list.add(future);
            }
            for (Future<String> f: list) {
                System.out.println(f.get());
            }
        }catch (Exception e){
            e.printStackTrace();
        }finally {
            //关闭线程池
            threadPool.shutdown();
        }
    }
}
class Worker implements Callable<String>{
    @Override
    public String call() throws Exception {
        System.out.println(Thread.currentThread().getName()+"线程运行中");
        return "true";
    }
}
```

## 11.4 线程池大小确定

线程数量过多的影响也是和我们分配多少人做事情一样，对于多线程这个场景来说主要是增加了**上下文切换**成本。

>上下文切换：
>
>多线程编程中一般线程的个数都大于 CPU 核心的个数，而一个 CPU 核心在任意时刻只能被一个线程使用，为了让这些线程都能得到有效执行，CPU 采取的策略是为每个线程分配时间片并轮转的形式。当一个线程的时间片用完的时候就会重新处于就绪状态让给其他线程使用，这个过程就属于一次上下文切换。概括来说就是：当前任务在执行完 CPU 时间片切换到另一个任务之前会先保存自己的状态，以便下次再切换回这个任务时，可以再加载这个任务的状态。**任务从保存到再加载的过程就是一次上下文切换**。
>
>上下文切换通常是计算密集型的。也就是说，它需要相当可观的处理器时间，在每秒几十上百次的切换中，每次切换都需要纳秒量级的时间。所以，上下文切换对系统来说意味着消耗大量的 CPU 时间，事实上，可能是操作系统中时间消耗最大的操作。
>
>Linux 相比与其他操作系统（包括其他类 Unix 系统）有很多的优点，其中有一项就是，其上下文切换和模式切换的时间消耗非常少。
>
>

有一个简单并且适用面比较广的公式：

- **CPU 密集型任务(N+1)：** 这种任务**消耗的主要是 CPU 资源，可以将线程数设置为 N（CPU 核心数）+1**，比 CPU 核心数多出来的一个线程是为了防止线程偶发的缺页中断，或者其它原因导致的任务暂停而带来的影响。一旦任务暂停，CPU 就会处于空闲状态，而在这种情况下多出来的一个线程就可以充分利用 CPU 的空闲时间。
- **I/O 密集型任务(2N)：** 这种任务应用起来，系统会用**大部分的时间来处理 I/O 交互，而线程在处理 I/O 的时间段内不会占用 CPU 来处理，这时就可以将 CPU 交出给其它线程使用。因此在 I/O 密集型任务的应用中，我们可以多配置一些线程，具体的计算方法是 2N**。

**如何判断是 CPU 密集任务还是 IO 密集任务？**

CPU 密集型简单理解就是利用 CPU 计算能力的任务比如你在内存中对大量数据进行排序。单凡涉及到网络读取，文件读取这类都是 IO 密集型，这类任务的特点是 CPU 计算耗费时间相比于等待 IO 操作完成的时间来说很少，大部分时间都花在了等待 IO 操作完成上。



# 12 函数式接口(必须掌握)

>函数式接口： 只有一个方法的接口  

## 12.1 Function接口

两个泛型参数：使用第一个泛型参数输入，返回第二个泛型参数输出

```java
//还有其他默认方法、静态方法
@FunctionalInterface
public interface Function<T, R> {

    /**
     * Applies this function to the given argument.
     *
     * @param t the function argument
     * @return the function result
     */
    R apply(T t);
}
```


```java
public class FunctionTest {
    public static void main(String[] args) {
//        Function<String,Integer> function = new Function<String, Integer>() {
//            @Override
//            public Integer apply(String s) {
//                return Integer.valueOf(s);
//            }
//        };

        Function<String,Integer> function = (t)->{return Integer.valueOf(t); };
        Integer num = 0;
        System.out.println(function.apply("12"));

    }
}
```

## 12.2Predicate接口

一个泛型参数，使用该泛型参数输入，返回boolean

```java
@FunctionalInterface
public interface Predicate<T> {

    /**
     * Evaluates this predicate on the given argument.
     *
     * @param t the input argument
     * @return {@code true} if the input argument matches the predicate,
     * otherwise {@code false}
     */
    boolean test(T t);
}
```

```java
public class PredicateTest {
    public static void main(String[] args) {
        Predicate<Integer> predicate = (t)->{
            if(t<10){
                return true;
            }
            return false;
        };
        System.out.println(predicate.test(13));
    };
}
```

## 12.3 Consumer接口

一个泛型参数，泛型参数输入，无输出

```java
@FunctionalInterface
public interface Consumer<T> {

    /**
     * Performs this operation on the given argument.
     *
     * @param t the input argument
     */
    void accept(T t);
}
```



```java
public class ConsumerTest {
    public static void main(String[] args) {
        Consumer<String> consumer = (t)->{
            System.out.println(t+" 被接受");
        };
        consumer.accept("你好");
    }
}
```

## 21.4 Supplier接口

一个泛型参数，无输入，返回该泛型参数

```java
@FunctionalInterface
public interface Supplier<T> {

    /**
     * Gets a result.
     *
     * @return a result
     */
    T get();
}
```



```java
public class SupplierTest {
    public static void main(String[] args) {
        LinkedList<String> list = new LinkedList<>();
        for (int i = 0; i < 10 ; i++) {
            list.add("data "+String.valueOf(i));
        }
        Supplier<String> supplier = ()->{
            if(list.isEmpty()){
                return "null";
            }
            return list.pop();
        };
        for (int i = 0; i < 12 ; i++) {
            System.out.println(supplier.get());
        }
    }
}
```

# 13 流式计算(没学)

![image-20220304110519749](C:\Users\jinhu\AppData\Roaming\Typora\typora-user-images\image-20220304110519749.png)

# 14  JMM(Java 内存模型)

在 JDK1.2 之前，Java 的内存模型实现总是从**主存**（即共享内存）读取变量，是不需要进行特别的注意的。而在当前的 Java 内存模型下，线程可以把变量保存**本地内存**（比如机器的寄存器）中，而不是直接在主存中进行读写。这就可能造成一个线程在主存中修改了一个变量的值，而另外一个线程还继续使用它在寄存器中的变量值的拷贝，造成**数据的不一致**。

[![JMM(Java内存模型)](https://camo.githubusercontent.com/0d7249a3f7a61706f94ff429328e2d28c19ccc4801370fa8d4f8cd2d290b895a/68747470733a2f2f67756964652d626c6f672d696d616765732e6f73732d636e2d7368656e7a68656e2e616c6979756e63732e636f6d2f323032302d382f30616337653636332d376462382d346239352d386438652d3764326231373966363765382e706e67)](https://camo.githubusercontent.com/0d7249a3f7a61706f94ff429328e2d28c19ccc4801370fa8d4f8cd2d290b895a/68747470733a2f2f67756964652d626c6f672d696d616765732e6f73732d636e2d7368656e7a68656e2e616c6979756e63732e636f6d2f323032302d382f30616337653636332d376462382d346239352d386438652d3764326231373966363765382e706e67)

要解决这个问题，就需要把变量声明为**`volatile`**，这就指示 JVM，这个变量是共享且不稳定的，每次使用它都到主存中进行读取。

所以，**`volatile` 关键字 除了防止 JVM 的指令重排 ，还有一个重要的作用就是保证变量的可见性。**

[![volatile关键字的可见性](https://camo.githubusercontent.com/21e256db07eef2a3b355db9d1ffbf2036dd3dc8c3a6fb41cd2fa4df0f4ba0e00/68747470733a2f2f67756964652d626c6f672d696d616765732e6f73732d636e2d7368656e7a68656e2e616c6979756e63732e636f6d2f323032302d382f64343963353535372d313430622d346162662d616461642d3861616333633930333663662e706e67)](https://camo.githubusercontent.com/21e256db07eef2a3b355db9d1ffbf2036dd3dc8c3a6fb41cd2fa4df0f4ba0e00/68747470733a2f2f67756964652d626c6f672d696d616765732e6f73732d636e2d7368656e7a68656e2e616c6979756e63732e636f6d2f323032302d382f64343963353535372d313430622d346162662d616461642d3861616333633930333663662e706e67)

**Volatile** 是可以保持 **可见性**。**不能保证原子性**，由于内存屏障，可以**保证避免指令重排**的现象产生！  



`synchronized` 关键字和 `volatile` 关键字是两个互补的存在，而不是对立的存在！

- **volatile 关键字**是线程同步的**轻量级实现**，所以**volatile 性能肯定比 synchronized 关键字要好**。但是**volatile 关键字只能用于变量而 synchronized 关键字可以修饰方法以及代码块**。
- **volatile 关键字能保证数据的可见性，但不能保证数据的原子性。synchronized 关键字两者都能保证。**
- **volatile 关键字主要用于解决变量在多个线程之间的可见性，而 synchronized 关键字解决的是多个线程之间访问资源的同步性**

# 15 ThreadLocal类

## 15.1 ThreadLocal 简介

通常情况下，我们创建的变量是可以被任何一个线程访问并修改的。**如果想实现每一个线程都有自己的专属本地变量该如何解决呢？** JDK 中提供的`ThreadLocal`类正是为了解决这样的问题。 **`ThreadLocal`类主要解决的就是让每个线程绑定自己的值，可以将`ThreadLocal`类形象的比喻成存放数据的盒子，盒子中可以存储每个线程的私有数据。**

**如果你创建了一个`ThreadLocal`变量，那么访问这个变量的每个线程都会有这个变量的本地副本，这也是`ThreadLocal`变量名的由来。他们可以使用 `get（）` 和 `set（）` 方法来获取默认值或将其值更改为当前线程所存的副本的值，从而避免了线程安全问题。**



![image-20220304141456470](C:\Users\jinhu\AppData\Roaming\Typora\typora-user-images\image-20220304141456470.png)

**示例**

```java
import java.text.SimpleDateFormat;
import java.util.Random;

public class ThreadLocalExample implements Runnable{

     // SimpleDateFormat 不是线程安全的，所以每个线程都要有自己独立的副本
    private static final ThreadLocal<SimpleDateFormat> formatter = ThreadLocal.withInitial(() -> new SimpleDateFormat("yyyyMMdd HHmm"));

    public static void main(String[] args) throws InterruptedException {
        ThreadLocalExample obj = new ThreadLocalExample();
        for(int i=0 ; i<10; i++){
            Thread t = new Thread(obj, ""+i);
            Thread.sleep(new Random().nextInt(1000));
            t.start();
        }
    }

    @Override
    public void run() {
        System.out.println("Thread Name= "+Thread.currentThread().getName()+" default Formatter = "+formatter.get().toPattern());
        try {
            Thread.sleep(new Random().nextInt(1000));
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        //formatter pattern is changed here by thread, but it won't reflect to other threads
        formatter.set(new SimpleDateFormat());

        System.out.println("Thread Name= "+Thread.currentThread().getName()+" formatter = "+formatter.get().toPattern());
    }

}
```

输出

```java
Thread Name= 0 default Formatter = yyyyMMdd HHmm
Thread Name= 0 formatter = yy-M-d ah:mm
Thread Name= 1 default Formatter = yyyyMMdd HHmm
Thread Name= 2 default Formatter = yyyyMMdd HHmm
Thread Name= 1 formatter = yy-M-d ah:mm
Thread Name= 3 default Formatter = yyyyMMdd HHmm
Thread Name= 2 formatter = yy-M-d ah:mm
Thread Name= 4 default Formatter = yyyyMMdd HHmm
Thread Name= 3 formatter = yy-M-d ah:mm
Thread Name= 4 formatter = yy-M-d ah:mm
Thread Name= 5 default Formatter = yyyyMMdd HHmm
Thread Name= 5 formatter = yy-M-d ah:mm
Thread Name= 6 default Formatter = yyyyMMdd HHmm
Thread Name= 6 formatter = yy-M-d ah:mm
Thread Name= 7 default Formatter = yyyyMMdd HHmm
Thread Name= 7 formatter = yy-M-d ah:mm
Thread Name= 8 default Formatter = yyyyMMdd HHmm
Thread Name= 9 default Formatter = yyyyMMdd HHmm
Thread Name= 8 formatter = yy-M-d ah:mm
Thread Name= 9 formatter = yy-M-d ah:mm
```

从输出中可以看出，Thread-0 已经改变了 formatter 的值，但仍然是 thread-2 默认格式化程序与初始化值相同，其他线程也一样。

上面有一段代码用到了创建 `ThreadLocal` 变量的那段代码用到了 Java8 的知识，它等于下面这段代码，如果你写了下面这段代码的话，IDEA 会提示你转换为 Java8 的格式(IDEA 真的不错！)。因为 ThreadLocal 类在 Java 8 中扩展，使用一个新的方法`withInitial()`，将 Supplier 功能接口作为参数。

~~~java
 private static final ThreadLocal<SimpleDateFormat> formatter = new ThreadLocal<SimpleDateFormat>(){
        @Override
        protected SimpleDateFormat initialValue()
        {
            return new SimpleDateFormat("yyyyMMdd HHmm");
        }
    };
~~~



## 15.2 ThreadLocal 内存泄露问题

`ThreadLocalMap` 中使用的 key 为 `ThreadLocal` 的弱引用,而 value 是强引用。所以，如果 `ThreadLocal` 没有被外部强引用的情况下，在垃圾回收的时候，key 会被清理掉，而 value 不会被清理掉。这样一来，`ThreadLocalMap` 中就会出现 key 为 null 的 Entry。假如我们不做任何措施的话，value 永远无法被 GC 回收，这个时候就可能会产生内存泄露。ThreadLocalMap 实现中已经考虑了这种情况，在调用 `set()`、`get()`、`remove()` 方法的时候，会清理掉 key 为 null 的记录。使用完 `ThreadLocal`方法后 最好手动调用`remove()`方法

```java
  static class Entry extends WeakReference<ThreadLocal<?>> {
        /** The value associated with this ThreadLocal. */
        Object value;

        Entry(ThreadLocal<?> k, Object v) {
            super(k);
            value = v;
        }
    }
```

# 16 线程安全的集合

## CopyOnWriteArrayList

~~~java
public class ListTest {
    public static void main(String[] args) {
        //并发情况下的ArrayList是不安全的的
        //解决方法
        /*
        *  1 使用Vector  List<String> list = new Vector<>();
        *    Vector jdk1.0  List 1.2
        *    他的add加入了synchronized同步
        *  2 使用List<String> list2 = Collections.synchronizedList(new ArrayList<>());转换
        *  3 juc  List<String> list3 = new CopyOnWriteArrayList<>();
        *    写入时复制， cow策略
        *    多个线程调用时，list读取时是固定的，写入可能存在覆盖
        *    在写入时避免覆盖，造成数据问题
        *    CopyOnWriteArrayList比Vector的优点：
        *    Vector使用了synchronized锁，CopyOnWriteArrayList使用lock锁，写入时复制
         */
        List<String> list1 = new Vector<>();
        List<String> list2 = Collections.synchronizedList(new ArrayList<>());
        List<String> list3 = new CopyOnWriteArrayList<>();

        List<String> list = new ArrayList<>();
        for (int i = 0; i < 10 ; i++) {
            new Thread(()-> {
                list3.add(UUID.randomUUID().toString().substring(0,5));
                System.out.println(list3);
            },String.valueOf(i)).start();
        }
//        for (int i = 0; i <10; i++) {
//            list.add(UUID.randomUUID().toString().substring(0,5));
//            System.out.println(list);
//
//        }
    }
}
~~~



## CopyOnWriteArraySet

```java
public class setList {
    public static void main(String[] args) {

        //解决方法
        /*
         *
         *  1 使用List<String> list2 = Collections.synchronizedList(new ArrayList<>());转换
         *  2 juc  Set<String> hashSet2 = new CopyOnWriteArraySet<>();
         *    写入时复制， cow策略
         *    多个线程调用时，list读取时是固定的，写入可能存在覆盖
         *    在写入时避免覆盖，造成数据问题
         *    CopyOnWriteArrayList比Vector的优点：
         *    Vector使用了synchronized锁，CopyOnWriteArrayList使用lock锁，写入时复制
         */
        Set<String> hashSet1 = Collections.synchronizedSet(new HashSet<>());
        Set<String> hashSet2 = new CopyOnWriteArraySet<>();
        Set<String> hashSet = new HashSet<>();
        for (int i = 0; i < 100; i++) {
            new Thread(()->{
                hashSet.add(UUID.randomUUID().toString().substring(0,5));
                System.out.println(hashSet);
            },String.valueOf(i)).start();
        }
    }
}
```



## ConcurrentHashMap

```java
public class MapTest {
    public static void main(String[] args) {

        Map<String, String> hashMap1 = Collections.synchronizedMap(new HashMap<>());
        //并发的HashMap
        Map<String, String> hashMap2 = new ConcurrentHashMap<>();
        //Map是怎样用的？默认等价与什么？HashMap<>(16,0.75);
        Map<String, String> hashMap = new HashMap<>();
        //加载因子，初始容量
        for (int i = 0; i <20 ; i++) {
            new Thread(()->{hashMap.put(Thread.currentThread().getName(), UUID.randomUUID().toString().substring(0,5));
                System.out.println(hashMap);
            },String.valueOf(i)).start();
        }
    }
}
```