### 一面

1. http和https区别？

   - https协议需要到CA（证书颁发机构）申请证书，需要一定的费用。
   - http是超文本传输协议，信息是明文传输。http是具有安全性的ssl加密传输协议。
   - http和https使用的端口也不一样，前者是80，后者是443。

   https的安全基础是ssl。ssl协议分为两层：1是ssl的记录协议，它建立在可靠的传输协议之上，为高层协议提供数据封装、压缩加密等基本功能支持。2是ssl握手协议，它建立在ssl记录协议之上，用于在实际数据传输开始前，通讯双方进行身份验证、协商加密算法、交换加密秘钥等。

 2. https原理

    - 客户使用https的url访问web服务器，要求与web服务器简历ssl链接。
    - web服务器收到客服端请求后会将网站的证书信息（证书信息含有公钥）传输一份给客户。
    - 客户端的浏览器与web服务器开始协商ssl链接的安全等级，也就是信息的加密等级。
    - 客户端的浏览器根据双方同意的安全等级建立会话秘钥，然后利用网站的公钥将会话秘钥加密，并传输给网站。
    - web服务器利用自己的私钥解出会话秘钥。
    - web服务器利用会话秘钥加密与客户端之间的通信。

    优点：

    - 安全

    缺点：

    - https握手阶段比较费时
    - ssl证书需要钱
    - ssl证书需要绑定ip，不能在同一个ip上绑定多个域名
    - ssl并不是一定安全。

	3. https为什么采用混合加密机制？

    一方面，第一阶段的非对称加密技术，保证了对称秘钥的安全性；第二阶段的对称加密，可以提高加密解密的速度，提高数据的传输效率。

	4. https支持什么加密算法？

    - 常见的对称加密算法：DES、IDEA、RC4、RC5、RC6和AES
    - 常见的非对称加密：RSA、ECC、DSA。
    - 常见的hash算法：MD2、MD4、MD5、HAVAL、SHA

 5. 虚拟内存是什么？

    - 虚拟内存是为了解决程序分到的物理地址不连续造成程序编写困难而产生的一项技术。
    - 虚拟内存是对物理内存的一种抽象，它介于物理内存和应用程序之间。应用程序不再是面向物理地址编程，应用程序在运行时只能使用虚拟内存地址。由cpu将虚拟内存地址翻译成物理地址。

    优点：

    - 应用程序只能看到之间的虚拟地址空间，从而保证了应用程序之间的内存隔离性，是应用程序运行更安全。
    - 每个应用程序的虚拟内存空间是连续的、统一的，从而降低了编程的复杂度。

6. 操作系统的中断有什么用？

   中断：指当出现需要时，CPU暂时停止当前程序的执行转而执行处理新情况的程序和执行过程。

   执行的顺序过程，类似于操作系统里面的动态的优先级调度算法。
   若当前没用程序中断请求时，先到的（当且仅当只有一个同时到达）直接进行中断服务。
   根据中断源的优先级来执行，若当前的中断程序优先级低于等待队列中（或刚进入）的中断程序，则当前中断程序进行中断，让出资源给优先级更高的中断程序。

 	7. java线程池的执行过程?
     - 判断核心线程数是否已满，没满则创建一个新的工作线程来执行任务。
     - 判断任务队列是否已满，没满则将新提交的任务添加到工作队列。
     - 判断整个线程池是否已满，没满则创建一个新的工作线程来执行任务，已满则启用拒绝策略。
     
	8. 线程池有哪些参数，各参数的作用是什么？
    - corePoolSize（核心工作线程数）：向线程池提交一个任务时，若线程池创建的线程数小于corePoolSize，即便此时存在空闲线程，也会通过创建一个新线程来执行任务，直到已创建的线程数大于corePoolSize。
    - maximumPoolSize（最大线程数）：线程池所允许的最大线程个数。当队列满了，且创建的线程数小于maximumPoolSize，则线程池创建新的线程来执行任务，另外对于无界队列，可忽略该参数。
    - keepAliveTime（多余线程存活时间）：当线程池中线程数大于核心线程数时，线程的空闲时间如果超过线程存活时间，那么这个线程将会被销毁，直到线程池中的线程数小于等于核心线程数为止。
    - workQueue（队列）：用于传输和保存等待执行任务的阻塞队列。
    - threadFactory（线程创建工厂）
    - handler（拒绝策略）：当线程池和队列都满了再加入线程时会执行拒绝策略。
	9. 线程池的拒绝策略有哪些？
    - AbortPolicy：丢弃任务并抛出异常。
    - DiscardPolicy：丢弃任务不抛异常。
    - DiscardOldestPolicy：丢弃队列最前面的任务，然后重新执行任务。
    - CallerRunsPolicy：调用者处理该任务。

 	10. 接口和抽象类的区别
      - 接口只能有静态常量，抽象类可以有自己的成员变量。
      - 接口不能实例化，没有构造函数。抽象类可以实例化，可以有构造函数。
      - 接口可以多实现，抽象类只能单继承。
      - 接口只能有抽象方法，抽象类有普通方法。
	11. mysql的ACID、及其实现
	12. redis分布式锁怎么实现

 	13. redis的持久化方式？
      - RDB持久化是redis默认采用的持久化方式，它以快照的形式将进程持久化到硬盘中。RDB会创建一个经过压缩的二进制文件，文件以“.rdb"结尾，内部存储了各个数据库的键值对信息。其优点是：RDB生成紧凑的二进制压缩文件，体积小，使用该文件恢复数据的速度非常快。缺点是：BGSAVE每次运行都要fork操作创建子进程，属于重量级操作，不宜频繁执行，所以RDB持久化没办法做到实时持久化。
      - AOF持久化：AOF持久化解决了数据持久化的实时性，是目前redis持久化的主流方式。AOF以独立日志的方式，记录每次的写入命令，重启时再重新执行AOF文件中的命令来恢复数据。优点：与RDB持久化可能丢失大量的数据相比，AOF持久化的安全性要高很多。通过使用everysec选型 ，用户可以将数据丢失的时间窗口控制在秒之内。缺点：AOF文件存储的是协议文本，它的体积比二进制格式的“.rdb”大很多。AOF需要通过执行AOF文件中的命令来恢复数据库，其恢复的速度比rdb慢很多。AOF在进行重写时也需要创建子进程，在数据库体积较大时将占用大量的资源。

14. 搭建项目遇到的问题。

15. 场景题（让你设计一个二维码扫描系统，你会怎么设计）

16. 然后就是手撕代码（删除链表重复字符串）

12. 重写equals为什么要重写hashcode？举个反例？

13. hashmap 源码？

14. spring解决循环依赖的问题？

15. java数组反转的接口？

16. hash函数的算法有哪些？

17. java的引用？

18. threadlocal内存泄露问题?