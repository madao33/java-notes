# 连接查询

## 去除重复记录

原表数据不会被修改，只是查询结果去除，关键字`distinct`

```java
mysql> select distinct job from emp;
+-----------+
| job       |
+-----------+
| CLERK     |
| SALESMAN  |
| MANAGER   |
| ANALYST   |
| PRESIDENT |
+-----------+
5 rows in set (0.00 sec)
```

> `distinct`只能出现在所有字段前面，表示所有字段联合起来去重
>
> ```java
> mysql> select distinct job, deptno from emp;
> +-----------+--------+
> | job       | deptno |
> +-----------+--------+
> | CLERK     |     20 |
> | SALESMAN  |     30 |
> | MANAGER   |     20 |
> | MANAGER   |     30 |
> | MANAGER   |     10 |
> | ANALYST   |     20 |
> | PRESIDENT |     10 |
> | CLERK     |     30 |
> | CLERK     |     10 |
> +-----------+--------+
> 9 rows in set (0.00 sec)
> ```

统计一下工作岗位的数量

```mysql
mysql> select count(distinct job) from emp;
+---------------------+
| count(distinct job) |
+---------------------+
|                   5 |
+---------------------+
1 row in set (0.00 sec)
```

## 连接查询基础知识

从一张表中单独查询，称为单表查询，从多张表联合起来查询数据，被称为连接查询

连接查询的分类：

按照年代

* `SQL92`：1992出现的语法
* `SQL99`：1999出现的语法

连接的方式

* 内连接
  * 等值连接
  * 非等值连接
  * 自连接
* 外连接
  * 左外连接（左连接）
  * 右外连接（右连接）

### 笛卡尔积现象

当两张表连接查询时，没有任何条件的限制会发生什么现象

```mysql
mysql> select ename, dname from emp, dept;
+--------+------------+
| ename  | dname      |
+--------+------------+
| SMITH  | OPERATIONS |
| SMITH  | SALES      |
| SMITH  | RESEARCH   |
| SMITH  | ACCOUNTING |
| ALLEN  | OPERATIONS |
| ALLEN  | SALES      |
| ALLEN  | RESEARCH   |
| ALLEN  | ACCOUNTING |
| WARD   | OPERATIONS |
| WARD   | SALES      |
| WARD   | RESEARCH   |
| WARD   | ACCOUNTING |
| JONES  | OPERATIONS |
| JONES  | SALES      |
| JONES  | RESEARCH   |
| JONES  | ACCOUNTING |
| MARTIN | OPERATIONS |
| MARTIN | SALES      |
| MARTIN | RESEARCH   |
| MARTIN | ACCOUNTING |
| BLAKE  | OPERATIONS |
| BLAKE  | SALES      |
| BLAKE  | RESEARCH   |
| BLAKE  | ACCOUNTING |
| CLARK  | OPERATIONS |
| CLARK  | SALES      |
| CLARK  | RESEARCH   |
| CLARK  | ACCOUNTING |
| SCOTT  | OPERATIONS |
| SCOTT  | SALES      |
| SCOTT  | RESEARCH   |
| SCOTT  | ACCOUNTING |
| KING   | OPERATIONS |
| KING   | SALES      |
| KING   | RESEARCH   |
| KING   | ACCOUNTING |
| TURNER | OPERATIONS |
| TURNER | SALES      |
| TURNER | RESEARCH   |
| TURNER | ACCOUNTING |
| ADAMS  | OPERATIONS |
| ADAMS  | SALES      |
| ADAMS  | RESEARCH   |
| ADAMS  | ACCOUNTING |
| JAMES  | OPERATIONS |
| JAMES  | SALES      |
| JAMES  | RESEARCH   |
| JAMES  | ACCOUNTING |
| FORD   | OPERATIONS |
| FORD   | SALES      |
| FORD   | RESEARCH   |
| FORD   | ACCOUNTING |
| MILLER | OPERATIONS |
| MILLER | SALES      |
| MILLER | RESEARCH   |
| MILLER | ACCOUNTING |
+--------+------------+
56 rows in set (0.01 sec)
```

> 当两张表进行连接查询，没有任何条件限制的时候，最终查询的结果，是两张表数目的乘积，这种现象被称为：笛卡尔积
>
> 连接的时候加条件，满足这个条件的记录被筛选出来

```mysql
mysql> select ename, dname from emp, dept where emp.deptno = dept.deptno;
+--------+------------+
| ename  | dname      |
+--------+------------+
| SMITH  | RESEARCH   |
| ALLEN  | SALES      |
| WARD   | SALES      |
| JONES  | RESEARCH   |
| MARTIN | SALES      |
| BLAKE  | SALES      |
| CLARK  | ACCOUNTING |
| SCOTT  | RESEARCH   |
| KING   | ACCOUNTING |
| TURNER | SALES      |
| ADAMS  | RESEARCH   |
| JAMES  | SALES      |
| FORD   | RESEARCH   |
| MILLER | ACCOUNTING |
+--------+------------+
14 rows in set (0.00 sec)
```

> 思考一下，最终查询结果的条数是14条，最终匹配的次数减少了吗？
>
> 还是同样的匹配次数 $n \times m$，次数没有减少，效率比较低，可以使用表起别名

```mysql
mysql> select e.ename, d.dname from emp e, dept d where e.deptno = d.deptno;
+--------+------------+
| ename  | dname      |
+--------+------------+
| SMITH  | RESEARCH   |
| ALLEN  | SALES      |
| WARD   | SALES      |
| JONES  | RESEARCH   |
| MARTIN | SALES      |
| BLAKE  | SALES      |
| CLARK  | ACCOUNTING |
| SCOTT  | RESEARCH   |
| KING   | ACCOUNTING |
| TURNER | SALES      |
| ADAMS  | RESEARCH   |
| JAMES  | SALES      |
| FORD   | RESEARCH   |
| MILLER | ACCOUNTING |
+--------+------------+
14 rows in set (0.00 sec)
```

> 上述的语法是`SQL92`语法
>
> 注意：通过笛卡尔积现象得出，表的连接次数越多，效率越低，尽量避免笛卡尔积现象

## 内连接

### 等值连接

查询每个员工所在的部门名称，显示员工名和部门名

`SQL99`语法

```mysql
mysql> select e.ename, d.dname from emp e join dept d on e.deptno = d.deptno;
+--------+------------+
| ename  | dname      |
+--------+------------+
| SMITH  | RESEARCH   |
| ALLEN  | SALES      |
| WARD   | SALES      |
| JONES  | RESEARCH   |
| MARTIN | SALES      |
| BLAKE  | SALES      |
| CLARK  | ACCOUNTING |
| SCOTT  | RESEARCH   |
| KING   | ACCOUNTING |
| TURNER | SALES      |
| ADAMS  | RESEARCH   |
| JAMES  | SALES      |
| FORD   | RESEARCH   |
| MILLER | ACCOUNTING |
+--------+------------+
14 rows in set (0.00 sec)
```

> `SQL99`倡导表连接和后续条件过滤分离，结构更加清晰
>
> `SQL92`的缺点：结构不够清晰，表的连接条件，和后期进一步筛选的条件，都放到`where`后面
>
> `SQL99`的优点：表连接的条件是独立的，连接之后，如果还需要进一步筛选，再往后继续添加`where`条件































