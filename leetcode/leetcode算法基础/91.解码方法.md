#### [91.解码方法](https://leetcode-cn.com/problems/decode-ways/)

难度中等1158收藏分享切换为英文接收动态反馈

一条包含字母 `A-Z` 的消息通过以下映射进行了 **编码** ：

```
'A' -> "1"
'B' -> "2"
...
'Z' -> "26"
```

要 **解码** 已编码的消息，所有数字必须基于上述映射的方法，反向映射回字母（可能有多种方法）。例如，`"11106"` 可以映射为：

- `"AAJF"` ，将消息分组为 `(1 1 10 6)`
- `"KJF"` ，将消息分组为 `(11 10 6)`

注意，消息不能分组为 `(1 11 06)` ，因为 `"06"` 不能映射为 `"F"` ，这是由于 `"6"` 和 `"06"` 在映射中并不等价。

给你一个只含数字的 **非空** 字符串 `s` ，请计算并返回 **解码** 方法的 **总数** 。

题目数据保证答案肯定是一个 **32 位** 的整数。

 

**示例 1：**

```
输入：s = "12"
输出：2
解释：它可以解码为 "AB"（1 2）或者 "L"（12）。
```

**示例 2：**

```
输入：s = "226"
输出：3
解释：它可以解码为 "BZ" (2 26), "VF" (22 6), 或者 "BBF" (2 2 6) 。
```

**示例 3：**

```
输入：s = "0"
输出：0
解释：没有字符映射到以 0 开头的数字。
含有 0 的有效映射是 'J' -> "10" 和 'T'-> "20" 。
由于没有字符，因此没有有效的方法对此进行解码，因为所有数字都需要映射。
```

 

**提示：**

- `1 <= s.length <= 100`
- `s` 只包含数字，并且可能包含前导零。

## 题解

### 动态规划数组实现

用`dp[i]`表示字符串前`i`个字符`s[1...i]`的解码方法数，考虑最后一次解码使用了`s`中的哪些字符，就会有下面两种情况：

* 第一种情况是使用了一个字符，那么只要 $s[i] \neq 0$，它就可以被解码成 $A-I$中的某个字母
  $$
  dp[i] = dp[i-1] \qquad s[i] \neq 0
  $$

* 第二种情况是我们使用了两个字符，即`s[i-1]`和`s[i]`进行编码，其中`s[i-1]`不能等于0，并且`s[i-1]`和`s[i]`组成的整数必须小于等于26
  $$
  dp[i] = dp[i-2] \quad (s[i-1] \neq 0 \ \&\& \ 10 \cdot s[i-1]+s[i] \leq 26)
  $$

将上面两种状态转移方程在对应的条件满足时进行累加，即可得到`dp[i]`的值，在动态规划完成之后，最终的答案即为`dp[n]`

```java
class Solution {
    public int numDecodings(String s) {
        int n = s.length();
        int[] dp = new int[n + 1];
        dp[0] = 1;
        for (int i = 1; i <= n; i++) {
            if (s.charAt(i-1) != '0')
                dp[i] += dp[i-1];
            if (i > 1 && s.charAt(i-2) != '0' && (s.charAt(i-2) - '0') * 10 + (s.charAt(i-1) - '0') <= 26)
                dp[i] += dp[i-2];
        }
        return dp[n];
    }
}
```

* 时间复杂度：$O(N)$
* 空间复杂度：$O(N)$

### 动态规划优化空间利用率

可以看到上述代码，动态规划转移过程只和前两项有关联，所以可以设置两个变量来代替数组，减少空间复杂度

```java
class Solution {
    public int numDecodings(String s) {
        int n = s.length();
        int a = 0, b = 1, c = 0;
        for (int i = 1; i <= n; i++) {
            c = 0;
            if (s.charAt(i-1) != '0')
                c += b;
            if (i > 1 && s.charAt(i-2) != '0' && (s.charAt(i-2) - '0') * 10 + (s.charAt(i-1) - '0') <= 26)
                c += a;
            a = b;
            b = c;
        }
        return c;
    }
}
```

* 时间复杂度：$O(N)$
* 空间复杂度：$O(1)$