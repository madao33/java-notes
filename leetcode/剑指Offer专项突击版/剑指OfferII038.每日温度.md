#### [剑指OfferII038.每日温度](https://leetcode-cn.com/problems/iIQa4I/)

难度中等26收藏分享切换为英文接收动态反馈

请根据每日 `气温` 列表 `temperatures` ，重新生成一个列表，要求其对应位置的输出为：要想观测到更高的气温，至少需要等待的天数。如果气温在这之后都不会升高，请在该位置用 `0` 来代替。

 

**示例 1:**

```
输入: temperatures = [73,74,75,71,69,72,76,73]
输出: [1,1,4,2,1,1,0,0]
```

**示例 2:**

```
输入: temperatures = [30,40,50,60]
输出: [1,1,1,0]
```

**示例 3:**

```
输入: temperatures = [30,60,90]
输出: [1,1,0]
```

 

**提示：**

- `1 <= temperatures.length <= 105`
- `30 <= temperatures[i] <= 100`

## 题解

这是一道比较典型的单调栈问题。
根据题意我们需要找到下一个更高的气温，然后计算两者相差的天数。
这里注意，如果气温在这之后都不会升高，则将该位置用0来代替。

根据以上的信息，我们可以先创建一个temperatures等长的全零数组，然后初始化一个栈
这里注意由于需要返回相差天数，所以栈中需要保存元素下标来实现天数计算。
下来循环temperatures进行栈的操作，循环过程中，持续判断当前下标温度与栈顶下标温度的大小差别
如果当前下标的温度大于栈顶下标的温度，表示找到了下一个更大的温度，弹出栈顶下标，计算天数差别，
更新ret[栈顶下标] = 当前下标 - 栈顶下标
否则将当前下标加入栈顶
ret中没有更新的元素，表示未找到更高的温度，最终返回ret即可。
这里模拟题目中示例1，给出栈和ret的变化，供大家参考：

输入: temperatures = [73,74,75,71,69,72,76,73]
输出: [1,1,4,2,1,1,0,0]
下标 -> 元素	栈	等待天数	说明
0 -> 73	[73]	[0, 0, 0, 0, 0, 0, 0, 0]	0入栈
1 -> 74	[74]	[1, 0, 0, 0, 0, 0, 0, 0]	0出栈、1入栈
2 -> 75	[75]	[1, 1, 0, 0, 0, 0, 0, 0]	1出栈、2入栈
3 -> 71	[75, 71]	[1, 1, 0, 0, 0, 0, 0, 0]	3入栈
4 -> 69	[75, 71, 69]	[1, 1, 0, 0, 0, 0, 0, 0]	4入栈
5 -> 72	[75, 72]	[1, 1, 0, 2, 1, 0, 0, 0]	3、4出栈，5入栈
6 -> 76	[76]	[1, 1, 4, 2, 1, 1, 0, 0]	2、5出栈、6入栈
7 -> 73	[76, 73]	[1, 1, 4, 2, 1, 1, 0, 0]	7入栈

```java
class Solution {
    public int[] dailyTemperatures(int[] temperatures) {
        Stack<Integer> stack = new Stack<>();
        int[] ret = new int[temperatures.length];
        for(int i = 0; i < temperatures.length; i++) {
            while(!stack.isEmpty() && temperatures[stack.peek()] < temperatures[i]) {
                int index = stack.pop();
                ret[index] = i - index;
            }
            stack.push(i);
        }
        return ret;
    }
}
```

